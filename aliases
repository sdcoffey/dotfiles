alias cls="clear"

alias up="cd .."
alias up2="cd ../.."
alias up3="cd ../../.."
alias up4="cd ../../../.."
alias up5="cd ../../../../.."
alias up6="cd ../../../../../.."

alias g="git"
alias v="vim"

alias k="kubectl"

alias watch="watch "

alias bi="bundle install"
alias be="bundle exec"

alias flushdns="sudo killall -HUP mDNSResponder"
alias sourcerc="source ~/.zshrc"

case "$(uname)" in
    Linux) alias ls='ls -F --color=auto';;
    *) alias ls='ls -FG';;
esac
alias la='ls -a'
alias ll='ls -alh'

mkcd () {
  mkdir -p -- "$1" && cd -P -- "$1"
}

nb () {
  new_branch=$1
  base_branch=$2

  if [[ -z "$base_branch" ]]; then
    base_branch=$NB_BASE_BRANCH
  fi

  if [[ -z "$base_branch" ]]; then
    base_branch="main"
  fi


  if [[ -z "$new_branch" ]]; then
    echo "usage: nb <new-branch-name> <base-branch-name>"
  else
    git fetch origin $base_branch:$base_branch
    git switch -c $new_branch $base_branch
  fi
}

last_commit() {
  base_branch="main"
  if [[ -n "$NB_BASE_BRANCH" ]]; then
    base_branch=$NB_BASE_BRANCH
  fi

  git fetch origin $base_branch > /dev/null 2>&1
  git log -1 --format="%H" | xargs echo -n
}

clone() {
  git clone "git@github.com:$1.git"
}

newpr() {
  local branch existing_url create_output status
  if ! command -v gh >/dev/null 2>&1; then
    echo "newpr: gh is not installed"
    return 1
  fi

  branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null) || {
    echo "newpr: not a git repo"
    return 1
  }
  if [[ "$branch" == "HEAD" ]]; then
    echo "newpr: detached HEAD"
    return 1
  fi

  existing_url=$(gh pr view --json url --jq .url 2>/dev/null) || true
  if [[ -z "$existing_url" || "$existing_url" == "null" ]]; then
    existing_url=$(gh pr list --head "$branch" --state all --limit 1 --json url --jq '.[0].url' 2>/dev/null) || true
  fi

  if [[ -n "$existing_url" && "$existing_url" != "null" ]]; then
    echo "$existing_url"
    return 0
  fi

  create_output=$(gh pr create --fill "$@")
  status=$?
  if [[ $status -ne 0 ]]; then
    return $status
  fi

  if [[ -n "$create_output" ]]; then
    printf '%s\n' "$create_output" | tail -n1
    return 0
  fi

  gh pr view --json url --jq .url
}

kill_on_port() {
  lsof -i $1 | tail -n1 | awk '{print $2}' | xargs kill
}

kill_grep() {
  ps aux |  grep $1 | grep -v "grep" | awk '{print $2}' | xargs kill
}

wip() {
  msg="$1"
  if [[ -z "$msg" ]]; then
    msg="wip"
  fi
  g add -A; g commit -m "$msg"
}

alias print256colors='(x=`tput op` y=`printf %80s`;for i in {0..256};do o=00$i;echo -e ${o:${#o}-3:3} `tput setaf $i;tput setab $i`${y// /=}$x;done)'
